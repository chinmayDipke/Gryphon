package DSA;

import java.util.Stack;

public class UseStack {

	public static void main(String[] args) {
		
		/*		
		Stack<Integer> s = new Stack();
		Stack<Integer> s1 = new Stack();
		
		s.push(3);
		s.push(23);
		s.push(34);
		s.push(91);
		s.push(92);
		s.push(98);
		
		System.out.println("Stack s: "+s);
		System.out.println("Stack s1: "+s1);
		System.out.println("Cap s1: "+s.size());
		
		
		for(int i = s.size()-1; i >= 0 ;i--) 
		{
			s1.push((s.get(i)));
		}
		System.out.println("=====================");
		System.out.println("Stack s: "+s);
		System.out.println("Stack s1: "+s1);
		
		System.out.println("===================================");
		*/
		
		Stack<Integer> stack = new Stack<>();
		
		stack.push(23);
		stack.push(92);
		stack.push(98);
		stack.push(31);
		stack.push(3);
		stack.push(34);
		
		System.out.println("Before Sort : "+stack);
		
		sort(stack);
		
		System.out.println("=====================");
		System.out.println("After Sort : "+stack);
		
	}

	private static void sortStack(Stack<Integer> stack) {
		
		Stack<Integer> tempStack = new Stack<>();
		
		//loop run until original brecomes empty
		while(!stack.isEmpty()) 
		{
			//pop the top element form original stack and store it in variable temp
			int temp = 0;
			
			//while tempstack is not empty and the top element of the tempstack is greater than
			//temp variable then move elements back to the original stack.
			while(!tempStack.isEmpty() && tempStack.peek() > temp)
			{
				//this makes room for the temp to be inserted in its correct sorted positin in tempstack
				stack.push(tempStack.pop());
			}
			//push variable into tempStak=ck at the right sorted position
			tempStack.push(temp);
			
		}
		//copy back
		//after sorting is done in tempStack, then tranfer all the elements back to the original stack to maintain
		//the correct stack structure with smallest elements at the top.
		while(!tempStack.isEmpty())
		{
			stack.push(tempStack.pop());
		}
	}
	static void sort(Stack<Integer> stack) {
		Stack<Integer> tempStack = new Stack<>();
		//loop run until the org stack becomes empty
		while(!stack.isEmpty()) {
			//pop the top elem from the org stack
			int temp = stack.pop();
			//while tempStack is not empty and the top elem of tempStack is greater than temp 			variable then move the elem back to the org stack
			while(!tempStack.isEmpty() && tempStack.peek()>temp) {
				//this makes room for the temp to be inserted in its correct sorted order 				position in tempStack
				stack.push(tempStack.pop());
			}
			//push temp variable into tempStack at the right sorted position
			tempStack.push(temp);
		}
		//copy back after the sorting is done in tempStack, then transfer all the elems back to 		the org stack to maintain the correct stack structure with the smallest elements at the 		top.
		while(!tempStack.isEmpty()) {
			stack.push(tempStack.pop());
		}
	}

}
